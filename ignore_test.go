package main

import (
	"errors"
	"io"
	"path/filepath"
	"regexp"
	"strings"
	"testing"
)

func TestIgnore(t *testing.T) {
	t.Parallel()

	for _, test := range []struct {
		FileName      string
		Contents      string
		DirsExpected  bool
		FilesExpected bool
		GenExpected   bool
	}{
		{
			FileName:     filepath.Join("foo", "bar", "zip.go"),
			Contents:     "blah blah...",
			DirsExpected: true,
		},
		{
			FileName:     filepath.Join("foo", "bar", "zip", "test.go"),
			Contents:     "blah blah...",
			DirsExpected: true,
		},
		{
			FileName:      filepath.Join("zip", "foobar", "gen.go"),
			Contents:      "blah blah...",
			FilesExpected: true,
		},
		{
			FileName: filepath.Join("foobar", "test.go"),
			Contents: `package test
// Code generated by zzz; DO NOT EDIT.`,
			GenExpected: true,
		},
		{
			FileName: filepath.Join("foobar", "test.go"),
			Contents: `package test
// AUTOGENERATED FILE: zzz stub code to make the package`,
			GenExpected: true,
		},
		{
			FileName: filepath.Join("foobar", "test.go"),
			Contents: `package test
// Code generated by zzz v1.0.0`,
			GenExpected: true,
		},
		{
			FileName: filepath.Join("foobar", "test.go"),
			Contents: strings.Repeat("x", 256) + `
// Code generated by zzz v1.0.0`,
		},
	} {
		t.Run(test.FileName, func(t *testing.T) {
			t.Parallel()
			c := []byte(test.Contents)

			empty := Ignore{}
			if empty.Match(test.FileName, nil) {
				t.Errorf("empty should NOT match %s+NO contents", test.FileName)
			}
			empty.cache = nil
			if empty.Match(test.FileName, c) {
				t.Errorf("empty should NOT match %s+contents", test.FileName)
			}

			dirs := Ignore{Dirs: regexp.MustCompile(`[\\/]bar$`)}
			if dirs.Match(test.FileName, nil) != test.DirsExpected {
				t.Errorf("dirs.Match(%s+NO contents) == %t but should be %t",
					test.FileName, !test.DirsExpected, test.DirsExpected)
			}
			dirs.cache = nil
			if dirs.Match(test.FileName, c) != test.DirsExpected {
				t.Errorf("dirs.Match(%s+contents) == %t but should be %t",
					test.FileName, !test.DirsExpected, test.DirsExpected)
			}

			files := Ignore{Files: regexp.MustCompile(`bar[\\/]gen\.go$`)}
			if files.Match(test.FileName, nil) != test.FilesExpected {
				t.Errorf("files.Match(%s+NO contents) == %t but should be %t",
					test.FileName, !test.FilesExpected, test.FilesExpected)
			}
			files.cache = nil
			if files.Match(test.FileName, c) != test.FilesExpected {
				t.Errorf("files.Match(%s+contents) == %t but should be %t",
					test.FileName, !test.FilesExpected, test.FilesExpected)
			}

			gen := Ignore{GeneratedFiles: true}
			if gen.Match(test.FileName, nil) {
				t.Errorf("gen should NOT match %s with no contents", test.FileName)
			}
			gen.cache = nil
			if gen.Match(test.FileName, c) != test.GenExpected {
				t.Errorf("gen.Match(%s+contents) == %t but should be %t",
					test.FileName, !test.GenExpected, test.GenExpected)
			}
		})
	}
}

func TestIgnoreReader(t *testing.T) {
	t.Parallel()

	ignore := &Ignore{
		Dirs:  regexp.MustCompile(`[\\/]bar$`),
		Files: regexp.MustCompile(`bar[\\/]gen\.go$`),
	}

	input := `mode: count
foo/bar/zip.go:10.1,20.1 5 1
foo/bar/zip/test.go:10.1,20.1 5 1
zip/foobar/gen.go:10.1,20.1 5 1
foobar/test.go:10.1,20.1 5 1
foobar/test2.go:10.1,20.1 5 1
`

	expected := `mode: count
foobar/test.go:10.1,20.1 5 1
foobar/test2.go:10.1,20.1 5 1
`

	ir := NewIgnoreReader(ignore, strings.NewReader(input))
	var sb strings.Builder
	if _, err := io.Copy(&sb, ir); err != nil {
		t.Fatalf("Copy failed: %v", err)
	}
	got := sb.String()
	if got != expected {
		t.Errorf("IgnoreReader result:\nGot:\n%s\nExpected:\n%s", got, expected)
	}
}

func TestIgnoreReader_Empty(t *testing.T) {
	t.Parallel()

	ignore := &Ignore{
		Dirs:  regexp.MustCompile(`[\\/]bar$`),
		Files: regexp.MustCompile(`bar[\\/]gen\.go$`),
	}
	input := `mode: count
`
	expected := `mode: count
`

	ir := NewIgnoreReader(ignore, strings.NewReader(input))
	var sb strings.Builder
	if _, err := io.Copy(&sb, ir); err != nil {
		t.Fatalf("Copy failed: %v", err)
	}
	got := sb.String()
	if got != expected {
		t.Errorf("IgnoreReader result:\nGot:\n%s\nExpected:\n%s", got, expected)
	}
}

func TestIgnoreReader_AllIgnored(t *testing.T) {
	t.Parallel()

	ignore := &Ignore{
		Dirs:  regexp.MustCompile(`[\\/]bar$`),
		Files: regexp.MustCompile(`bar[\\/]gen\.go$`),
	}
	input := `mode: count
foo/bar/zip.go:10.1,20.1 5 1
foo/bar/zip/test.go:10.1,20.1 5 1
zip/foobar/gen.go:10.1,20.1 5 1
`
	expected := `mode: count
`

	ir := NewIgnoreReader(ignore, strings.NewReader(input))
	var sb strings.Builder
	if _, err := io.Copy(&sb, ir); err != nil {
		t.Fatalf("Copy failed: %v", err)
	}
	got := sb.String()
	if got != expected {
		t.Errorf("IgnoreReader result:\nGot:\n%s\nExpected:\n%s", got, expected)
	}
}

type oneByteAtATimeReader struct {
	data []byte
	pos  int
}

func (r *oneByteAtATimeReader) Read(p []byte) (n int, err error) {
	if r.pos >= len(r.data) {
		return 0, io.EOF
	}
	p[0] = r.data[r.pos]
	r.pos++
	return 1, nil
}

func TestIgnoreReader_SlowSource(t *testing.T) {
	t.Parallel()

	slowSource := &oneByteAtATimeReader{data: []byte(`mode: count
foo/bar/zip.go:10.1,20.1 5 1
foo/bar/zip/test.go:10.1,20.1 5 1
zip/foobar/gen.go:10.1,20.1 5 1
foobar/test.go:10.1,20.1 5 1
foobar/test2.go:10.1,20.1 5 1
`)}

	ignore := &Ignore{
		Dirs:  regexp.MustCompile(`[\\/]bar$`),
		Files: regexp.MustCompile(`bar[\\/]gen\.go$`),
	}
	expected := `mode: count
foobar/test.go:10.1,20.1 5 1
foobar/test2.go:10.1,20.1 5 1
`

	ir := NewIgnoreReader(ignore, slowSource)
	var sb strings.Builder
	if _, err := io.Copy(&sb, ir); err != nil {
		t.Fatalf("Copy failed: %v", err)
	}
	got := sb.String()
	if got != expected {
		t.Errorf("IgnoreReader result:\nGot:\n%s\nExpected:\n%s", got, expected)
	}
}

func TestIgnoreReader_SlowUser(t *testing.T) {
	t.Parallel()

	ignore := &Ignore{
		Dirs:  regexp.MustCompile(`[\\/]bar$`),
		Files: regexp.MustCompile(`bar[\\/]gen\.go$`),
	}

	input := `mode: count
foo/bar/zip.go:10.1,20.1 5 1
foo/bar/zip/test.go:10.1,20.1 5 1
zip/foobar/gen.go:10.1,20.1 5 1
foobar/test.go:10.1,20.1 5 1
foobar/test2.go:10.1,20.1 5 1
`

	expected := `mode: count
foobar/test.go:10.1,20.1 5 1
foobar/test2.go:10.1,20.1 5 1
`

	ir := NewIgnoreReader(ignore, strings.NewReader(input))
	var sb strings.Builder
	buf := make([]byte, 1)
	for {
		n, err := ir.Read(buf)
		sb.Write(buf[:n])
		if errors.Is(err, io.EOF) {
			break
		}
		if err != nil {
			t.Fatalf("Read failed: %v", err)
		}
	}
	got := sb.String()
	if got != expected {
		t.Errorf("IgnoreReader result:\nGot:\n%s\nExpected:\n%s", got, expected)
	}
}
